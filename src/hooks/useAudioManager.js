import { useEffect, useRef } from 'react';
import { useAppStore } from '../store/appStore';

const frequencies = {
  coherence: { base: 256, beat: 0.1, name: 'Coh√©rence 0.1Hz' },
  '396hz': { base: 396, beat: 5, name: 'Lib√©ration 396Hz' },
  '432hz': { base: 432, beat: 8, name: 'Harmonie Naturelle 432Hz' },
  '528hz': { base: 528, beat: 6, name: 'Amour & Gu√©rison 528Hz' },
  '639hz': { base: 639, beat: 7, name: 'Relations 639Hz' },
  '741hz': { base: 741, beat: 9, name: '√âveil de l\'Intuition 741Hz' },
  '852hz': { base: 852, beat: 10, name: 'Retour √† l\'Ordre Spirituel 852Hz' },
  '174hz': { base: 174, beat: 3, name: 'Fr√©quence de la Terre 174Hz' },
  '285hz': { base: 285, beat: 4, name: 'R√©g√©n√©ration Cellulaire 285Hz' },
  theta: { base: 200, beat: 4.5, name: 'Ondes Theta (4.5Hz)' },
  theta6: { base: 200, beat: 6, name: 'Ondes Theta (6Hz)' },
  theta783: { base: 200, beat: 7.83, name: 'Ondes Theta (7.83Hz)' },
  alpha: { base: 300, beat: 10, name: 'Ondes Alpha (10Hz)' },
  beta: { base: 400, beat: 14, name: 'Ondes Beta (14Hz)' },
  delta: { base: 150, beat: 2, name: 'Ondes Delta (2Hz)' },
  gamma: { base: 500, beat: 40, name: 'Ondes Gamma (30-100Hz)' },
};

const sessionFrequencies = {
  // COH√âRENCE CARDIAQUE INT√âGRATIVE
  coherence: 'coherence',        // 0.1 Hz

  // URGENCE & R√âALIGNEMENT
  switch: '396hz',               // 396 Hz - Lib√©ration
  reset: 'theta',                // Ondes Theta 4.5 Hz

  // INITIATION & PERFECTIONNEMENT
  progressive: 'alpha',          // Ondes Alpha 10 Hz (TRAINING)
  free: '432hz',                 // 432 Hz - Harmonie Naturelle (SESSION LIBRE)

  // ESPACE ENFANTS & SENIORS
  kids: '528hz',                 // 528 Hz - Amour & Gu√©rison
  seniors: 'theta783',           // Ondes Theta 7.83 Hz

  // VOYAGE INT√âRIEUR
  scan: 'theta6',                // Ondes Theta 6 Hz (SCAN CORPOREL)

  // M√âDITATIONS TH√âMATIQUES
  gratitude: '528hz',            // 528 Hz (amour/reconnaissance)
  abundance: '639hz',            // 639 Hz (ouverture/connexion)
  love: '528hz',                 // 528 Hz (√©vident)
  attraction: '432hz',           // 432 Hz (alignement universel)
  confidence: 'beta',            // Ondes Beta 14 Hz (affirmation/action)
  sleep: 'delta',                // Ondes Delta 2 Hz (sommeil r√©parateur)
};

export const useAudioManager = () => {
  const { audioSettings, currentSession, currentMeditation, isSessionActive } = useAppStore();
  const audioContextRef = useRef(null);
  const oscillatorsRef = useRef(null);
  const gainNodeRef = useRef(null);
  const isPlayingRef = useRef(false);
  const sessionStartTimeRef = useRef(null);
  const breathingStateRef = useRef({ phase: 'idle', inhaleTime: 5, exhaleTime: 5 });

  const initAudioContext = () => {
    if (!audioContextRef.current) {
      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    // Reprendre le contexte audio s'il est suspendu
    if (audioContextRef.current.state === 'suspended') {
      audioContextRef.current.resume();
    }
    
    return audioContextRef.current;
  };

  const getDefaultFrequency = () => {
    if (currentSession === 'meditation' && currentMeditation) {
      return sessionFrequencies[currentMeditation] || 'coherence';
    }
    return sessionFrequencies[currentSession || 'coherence'] || 'coherence';
  };

  const startAudio = (frequency) => {
    if (!audioSettings.enabled || isPlayingRef.current) return;

    console.log('üéµ D√âMARRAGE AUDIO - Session:', currentSession, 'Fr√©quence:', frequency);
    
    const selectedFrequency = frequency || getDefaultFrequency();
    const freq = frequencies[selectedFrequency];
    if (!freq) {
      console.error('‚ùå Fr√©quence non trouv√©e:', selectedFrequency);
      return;
    }

    const audioContext = initAudioContext();
    sessionStartTimeRef.current = Date.now();

    try {
      // Cr√©er les oscillateurs
      const oscillatorLeft = audioContext.createOscillator();
      const oscillatorRight = audioContext.createOscillator();

      oscillatorLeft.type = 'sine';
      oscillatorRight.type = 'sine';
      oscillatorLeft.frequency.value = freq.base;
      oscillatorRight.frequency.value = freq.base + freq.beat;

      // Cr√©er les n≈ìuds de gain et de panoramique
      const gainNode = audioContext.createGain();
      const pannerLeft = audioContext.createStereoPanner();
      const pannerRight = audioContext.createStereoPanner();

      pannerLeft.pan.value = -1;
      pannerRight.pan.value = 1;
      
      const recommendedVolume = audioSettings.volume * 0.25;
      gainNode.gain.value = recommendedVolume;

      // Connecter les n≈ìuds
      oscillatorLeft.connect(pannerLeft);
      oscillatorRight.connect(pannerRight);
      pannerLeft.connect(gainNode);
      pannerRight.connect(gainNode);
      gainNode.connect(audioContext.destination);

      // Fade in progressif
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(recommendedVolume, audioContext.currentTime + 2);

      // D√©marrer les oscillateurs SANS LIMITE DE TEMPS
      oscillatorLeft.start();
      oscillatorRight.start();

      // Stocker les r√©f√©rences
      oscillatorsRef.current = { left: oscillatorLeft, right: oscillatorRight };
      gainNodeRef.current = gainNode;
      isPlayingRef.current = true;

      console.log(`üéµ Audio d√©marr√© avec succ√®s: ${freq.name} (${selectedFrequency})`);
      console.log('üîä Volume:', recommendedVolume, 'Base freq:', freq.base, 'Beat:', freq.beat);
      
      // Gestion des erreurs d'oscillateur
      oscillatorLeft.onended = () => {
        console.log('üîÑ Oscillateur gauche termin√©');
      };
      
      oscillatorRight.onended = () => {
        console.log('üîÑ Oscillateur droit termin√©');
      };

    } catch (error) {
      console.error('‚ùå Erreur lors du d√©marrage audio:', error);
      isPlayingRef.current = false;
    }
  };

  const stopAudio = () => {
    if (!isPlayingRef.current || !oscillatorsRef.current || !gainNodeRef.current) {
      console.log('üîá Aucun audio √† arr√™ter');
      return;
    }

    const audioContext = audioContextRef.current;
    if (!audioContext) {
      console.log('üîá Pas de contexte audio');
      return;
    }

    const sessionDuration = sessionStartTimeRef.current ? 
      (Date.now() - sessionStartTimeRef.current) / 1000 : 0;
    
    console.log('üîá ARR√äT AUDIO - Dur√©e de session:', Math.round(sessionDuration), 'secondes');

    try {
      // Fade out progressif
      gainNodeRef.current.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);

      setTimeout(() => {
        if (oscillatorsRef.current) {
          try {
            oscillatorsRef.current.left.stop();
            oscillatorsRef.current.right.stop();
          } catch (error) {
            console.log('‚ö†Ô∏è Oscillateurs d√©j√† arr√™t√©s');
          }
          oscillatorsRef.current = null;
        }
        gainNodeRef.current = null;
        isPlayingRef.current = false;
        sessionStartTimeRef.current = null;
        console.log('‚úÖ Audio compl√®tement arr√™t√©');
      }, 1000);
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'arr√™t audio:', error);
      // Force cleanup en cas d'erreur
      oscillatorsRef.current = null;
      gainNodeRef.current = null;
      isPlayingRef.current = false;
      sessionStartTimeRef.current = null;
    }
  };

  // NOUVEAU : Fonction pour mettre √† jour l'√©tat respiratoire
  const updateBreathingState = (breathingState) => {
    breathingStateRef.current = breathingState;
  };

  const playGong = (type = 'inhale') => {
    if (!audioSettings.gongEnabled) {
      console.log('üîï Gong d√©sactiv√©');
      return;
    }

    console.log('üîî GONG CONTINU:', type, '- √âtat respiratoire:', breathingStateRef.current);

    const audioContext = initAudioContext();
    const now = audioContext.currentTime;

    // Calculer la dur√©e du gong bas√©e sur le cycle respiratoire
    const currentBreathing = breathingStateRef.current;
    let gongDuration;
    
    if (type === 'inhale') {
      // Le gong d'inspiration dure jusqu'au d√©but de l'expiration
      gongDuration = (currentBreathing.inhaleTime || 5) + (currentBreathing.holdTime || 0);
    } else if (type === 'exhale') {
      // Le gong d'expiration dure toute la dur√©e de l'expiration
      gongDuration = currentBreathing.exhaleTime || 5;
    } else {
      // Dur√©e par d√©faut
      gongDuration = 5;
    }

    // Assurer une dur√©e minimale et maximale raisonnable
    gongDuration = Math.max(3, Math.min(gongDuration, 10));

    console.log('üîî Dur√©e gong calcul√©e:', gongDuration, 'secondes pour', type);

    try {
      const osc1 = audioContext.createOscillator();
      const osc2 = audioContext.createOscillator();
      const osc3 = audioContext.createOscillator();

      const gainNode = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();

      // Fr√©quences diff√©rentes pour inspiration et expiration
      const baseFreq = type === 'inhale' ? 261.63 : 220.00; // Do4 pour inspiration, La3 pour expiration
      osc1.frequency.setValueAtTime(baseFreq, now);
      osc2.frequency.setValueAtTime(baseFreq * 0.5, now);
      osc3.frequency.setValueAtTime(baseFreq * 1.5, now);

      osc1.type = 'sine';
      osc2.type = 'sine';
      osc3.type = 'sine';

      // Filtre passe-bas pour adoucir le son
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1200, now);
      filter.Q.setValueAtTime(2, now);
      filter.frequency.exponentialRampToValueAtTime(600, now + gongDuration);

      const recommendedGongVolume = audioSettings.gongVolume * 0.15;
      
      // NOUVEAU : Enveloppe sonore continue avec diminution progressive
      gainNode.gain.setValueAtTime(0, now);
      gainNode.gain.linearRampToValueAtTime(recommendedGongVolume, now + 0.05); // Attaque rapide
      gainNode.gain.linearRampToValueAtTime(recommendedGongVolume * 0.8, now + 0.2); // Sustain initial
      gainNode.gain.linearRampToValueAtTime(recommendedGongVolume * 0.6, now + gongDuration * 0.3); // Diminution graduelle
      gainNode.gain.linearRampToValueAtTime(recommendedGongVolume * 0.4, now + gongDuration * 0.6); // Continue √† diminuer
      gainNode.gain.linearRampToValueAtTime(recommendedGongVolume * 0.2, now + gongDuration * 0.8); // Presque fini
      gainNode.gain.exponentialRampToValueAtTime(0.001, now + gongDuration); // Fade out final

      // Connecter les n≈ìuds
      osc1.connect(filter);
      osc2.connect(filter);
      osc3.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(audioContext.destination);

      // D√©marrer et programmer l'arr√™t
      osc1.start(now);
      osc2.start(now);
      osc3.start(now);
      osc1.stop(now + gongDuration + 0.1); // Petit buffer pour √©viter les coupures
      osc2.stop(now + gongDuration + 0.1);
      osc3.stop(now + gongDuration + 0.1);

      console.log('üîî Gong continu jou√© avec succ√®s - Dur√©e:', gongDuration, 's');
    } catch (error) {
      console.error('‚ùå Erreur gong:', error);
    }
  };

  // Surveiller l'√©tat de la session pour maintenir l'audio
  useEffect(() => {
    if (isSessionActive && !isPlayingRef.current && audioSettings.enabled) {
      console.log('üîÑ Session active d√©tect√©e, red√©marrage audio si n√©cessaire');
      // Red√©marrer l'audio si la session est active mais l'audio arr√™t√©
      const frequency = getDefaultFrequency();
      startAudio(frequency);
    } else if (!isSessionActive && isPlayingRef.current) {
      console.log('üîÑ Session inactive d√©tect√©e, arr√™t audio');
      stopAudio();
    }
  }, [isSessionActive, audioSettings.enabled]);

  // Surveiller les changements de volume en temps r√©el
  useEffect(() => {
    if (isPlayingRef.current && gainNodeRef.current && audioContextRef.current) {
      const newVolume = audioSettings.volume * 0.25;
      gainNodeRef.current.gain.setValueAtTime(newVolume, audioContextRef.current.currentTime);
      console.log('üîä Volume mis √† jour:', newVolume);
    }
  }, [audioSettings.volume]);

  // Nettoyage √† la destruction du composant
  useEffect(() => {
    return () => {
      console.log('üßπ Nettoyage useAudioManager');
      stopAudio();
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
  }, []);

  return {
    startAudio,
    stopAudio,
    playGong,
    updateBreathingState, // NOUVEAU : Exposer la fonction de mise √† jour
    isPlaying: isPlayingRef.current,
    getDefaultFrequency,
    getCurrentFrequencyName: () => {
      const freq = getDefaultFrequency();
      return frequencies[freq]?.name || 'Coh√©rence 0.1Hz';
    },
  };
};